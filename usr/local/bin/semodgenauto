#!/usr/bin/env python3
from os import getcwd,listdir
from os.path import abspath,basename,dirname,expanduser,isdir,isfile,join
from selinux import getfilecon
from shutil import copytree,move
from subprocess import run
from sys import argv,exit

###################
### DIRECTORIES ###
###################
# Full path to the directory containing the template SELinux policy module and shell script for labelling
template = expanduser('/usr/local/share/hardhat-selinux/templates/labels')

################
### BINARIES ###
################
seinfo = expanduser('/usr/bin/seinfo')

#############
### USAGE ###
#############
def usage():
    target = basename(argv[0])
    print(f"NAME\n\t{target} - python script to automatically generate a SELinux policy module for the specified file/directory\n")
    print(f"SYNOPSIS\n\t{target} /path/to/file_or_dir [OPTIONS]\n")
    print(f"DESCRIPTION\n\t{target} is a Python script provided by the HardHat project that automatically generates a SELinux policy module (label only) for the specified file/directory.\n")
    print(f"OPTIONS\n\t-d\tDirectory to output the generated SELinux policy module directory\n\t-h\tDisplay this message\n\t-l\tCustom label to use\n\t-n\tName of the SELinux policy module directory to create\n")
    print(f"EXAMPLE\n\t1. {target} /usr/bin/cat\n\n\t2. {target} /usr/bin/cat -d /home/user/selinux\n\n\t3. {target} /usr/bin/cat -l custom_label_t\n\n\t4. {target} /usr/bin/cat -d ~/output_dir -l custom_label_t\n\n\t5. {target} /usr/bin/cat -d /tmp -l label_t -n cat_label_dir\n")
    print("\n")

#################
### FUNCTIONS ###
#################
def args():
    # Check if the user has specified the help flag (any argument)
    if any([True for arg in argv if arg == '-h']):
        # If so, then display the usage information
        usage()
        # Exit
        exit(0)
    try:
        # Argument 1: Full path to the file/directory to generate a label for
        target = abspath(expanduser(argv[1]))
    except IndexError:
        # If argument was not specified, then display the usage information
        usage()
        # Display an error message to user
        print('ERROR: No file or directory specified')
        # Exit with an error
        exit(1)
    #----------------------#
    #-- OUTPUT DIRECTORY --#
    #----------------------#
    # Optional Flag: Path to the directory where the SELinux policy module directory for $target will be created
    outdir = options('-d')
    # If no $outdir is specified, then default to the user's current working directory
    outdir = getcwd()
    #------------------#
    #-- CUSTOM LABEL --#
    #------------------#
    # Optional Flag: Custom label to use for the SELinux policy module
    label = options('-l')
    #----------#
    #-- NAME --#
    #----------#
    name = options('-n')
    # Return the arguments
    return(target, outdir, label, name)

def options(flag):
    try:
        # Define the $value of the specified $flag to be the next index
        value = [argv[i + 1] for i in range(2, len(argv)) if argv[i].strip() == flag]
    except IndexError:
        # If the $flag was specified but there was no value, then display an error message to user
        print(f"ERROR: Please pass the value for the flag: '{flag}'")
        # Exit with an error
        exit(1)
    try:
        # Define the $value and remove extraneous whitespace
        value = value[0].strip()
    except IndexError:
        # If the $flag was not found, then return False
        return(False)
    # Check if the $value for $flag starts with a dash. This means that there was no value specified by the user and another flag is being mistaken as the value
    if value.startswith('-'):
        # If the $flag was specified but there was no value, then display an error message to user
        print(f"ERROR: Please pass the value for the flag: '{flag}'")
        # Exit with an error
        exit(1)
    # Return the $value for the specified $flag
    return(value)

def is_exists(target):
    # If $target is a valid directory or valid file, then return True
    if isdir(target) or isfile(target): return(True)
    # Otherwise, display an error message to user
    print(f"ERROR: Unable to find the following file or directory: '{target}'")
    # Exit with an error
    exit(1)

def type_attributes(target):
    # Obtain the SELinux contexts for $target, which will provide the user, role, and type for $target as the last entry in the output list
    contexts = getfilecon(target)[-1]
    try:
        # Split $contexts via the semicolon to separate the user, role, type, and then obtain the entry that ends with '_t' to define the type. Finally, use `.strip()` to remove any extraneous whitespace
        context_type = [entry for entry in contexts.split(':') if entry.strip().endswith('_t')][0].strip()
    except IndexError:
        # If the type was not found, then display an error message to user
        print(f"ERROR: Unable to obtain the SELinux type (eg. 'bin_t', 'lib_t', etc.) for '{target}'")
        # Exit with an error
        exit(1)
    # Use `seinfo` to obtain the attributes for $context_type
    # '--flat' = Exclude headers and other identifiers; makes it easier for scripts
    # '-x' = Show the attributes for the $context_type
    # '-t' = Specify that a type is being queried
    cmd = run([seinfo, '--flat', '-x', '-t', context_type], capture_output = True) 
    # Check if the $cmd successfully executed
    if cmd.returncode != 0:
        # If not, then display an error message to user
        print(f"ERROR: The `seinfo` command failed to execute:\n\n\t{cmd}")
        # Exit with an error
        exit(1)
    # Obtain the attributes for the $context_type, which will be used for $target. This is done by keeping all entries from the `seinfo` command except the first, which contains the name and aliases for the $context_type that is not needed
    attributes = ', '.join([entry.strip() for entry in cmd.stdout.decode().split(',') if not entry.startswith('type')])
    # Return $attributes
    return(attributes)

def selinux_changes(target):
    # Change all periods in $target to underscores
    target = target.replace('.', '_')
    # Change all pluses to in $target to 'pp'
    target = target.replace('+', 'p')
    # SELinux does not utilize /usr/lib64 and will instruct users to specify '/usr/lib' instead
    target = target.replace('/usr/lib64', '/usr/lib')
    # Return all changes made to $target
    return(target)

def copy_template(dest):
    try:
        # Copy the $src template directory to $dest
        copytree(template, dest)
    except FileExistsError:
        # If the directory already exists at $dest, display an error message to user
        print(f"ERROR: Directory already exists: '{dest}'")
        # Exit with an error
        exit(1)

class edit:
    def __init__(self, dct, dest):
        # Define and verify the SELinux policy module and shell script used for labelling are present in $dest
        [template_te, label_sh] = self.define(dest)
        # Edit the SELinux policy module to specify the correct names and attributes
        self.write(dct, label_sh)
        # Edit the shell script that applies the SELinux policy module label to specify the correct name and path
        self.write(dct, template_te)
        # Rename the 'template.te' file to reflect the $selinux_changes_target, which is also used as the module name
        self.mv(template_te)

    def define(self, dest):
        # Define the SELinux policy module file that should exist within $dest
        template_te = join(dest, 'template.te')
        # Define the shell script that labels that should exist within $dest
        label_sh = join(dest, 'label.sh')
        # Verify both of these files exist
        is_exists(template_te)
        is_exists(label_sh)
        # Return both file variables
        return(template_te, label_sh)

    def write(self, dct, filename):
        # Open $filename and obtain its contents
        with open(filename, 'r') as f: contents = f.readlines()
        for placeholder in dct: contents = [entry.replace(placeholder, dct[placeholder]) for entry in contents]
        # Overwrite $filename with the new $contents 
        with open(filename, 'w') as f: f.write(''.join(contents))

    def mv(self, template_te):
        # Obtain the full path to $template_te
        root = dirname(template_te)
        # Obtain the contents of $template_te
        with open(template_te, 'r') as f: contents = f.readlines()
        try:
            # Obtain the first entry of $contents, which corresponds to the first line of $template_te
            module_name = contents[0]
        except IndexError:
            # If the first line of $template_te could not be obtained (the file is empty), then display an error message to user
            print(f"ERROR: The specified template SELinux policy module file is empty: '{template_te}'")
            # Exit with an error
            exit(1)
        try:
            # Define the full path to the new SELinux policy module file, renamed from 'template.te'. The name is created by splitting the $module_name via spaces to obtain the list: ['module', $name, '1.0.0.0;']. Then, obtain only the $name and remove all extraneous whitespace, making sure to add the '.te' extension for the filename
            renamed_template_te = join(root, f"{module_name.split()[1].strip()}.te")
        except IndexError:
            # If the full path to the new SELinux policy module file could not be defined above, then display an error message to user
            print(f"ERROR: Unable to obtain the module name from the specified template SELinux file: '{template_te}'")
            # Exit with an error
            exit(1)
        # Perform the rename
        move(template_te, renamed_template_te)

############
### MAIN ###
############
def main(target, outdir, label, name):
    # Verify $target is a valid file or directory
    is_exists(target) 
    # Verify $outdir is a valid directory
    is_exists(outdir)
    # Obtain the attributes of the current type associated with $target
    attributes = type_attributes(target)
    # Perform SELinux specific changes to $target and remove its path 
    selinux_changes_target = basename(selinux_changes(target))
    # Perform SELinux specific changes only the path, not $target itself
    selinux_changes_target_path = join(selinux_changes(dirname(target)), basename(target))
    # Define the destination directory that will contain the new SELinux policy module for $target.
    dest = join(outdir, selinux_changes_target)
    # If $name has been specified, then set the $dest directory to be $outdir/$name
    if name is not False: dest = join(outdir, name)
    # Create the SELinux policy module directory for $target using $template
    copy_template(dest)
    # Create a dictionary to contain the placeholders within the template.te file and the values will be the replacements
    dct = {'ATTRIBUTE': attributes, 'NAME_PATH': selinux_changes_target_path, 'NAME_t': f"{selinux_changes_target}_t"}
    # If $label has been specified, then set the 'NAME_t' placeholder to $label 
    if label is not False: dct['NAME_t'] = label
    # If $name has been specified, then create the 'module NAME' entry and set its replacement to 'module $name' instead
    if name is not False: dct['module NAME'] = f"module {name}"
    dct['NAME'] = selinux_changes_target
    # Edit the template files to reflect $target
    edit(dct, dest)

#############
### START ###
#############
if __name__ == '__main__':
    # Verify $template is a valid directory
    is_exists(template)
    # Verify the $seinfo binary exists, used to obtain the attributes of SELinux types
    is_exists(seinfo)
    # Parse user-specified arguments
    [target, outdir, label, name] = args()
    # Execute the main script
    main(target, outdir, label, name)
